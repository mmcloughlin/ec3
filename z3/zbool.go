// Code generated by wrap.go. DO NOT EDIT.

package z3

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
*/
import "C"

// Not returns not(x).
// Corresponds to Z3_mk_not.
func (x *Bool) Not() *Bool {
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_not(x.ctx, x.ast),
		},
	}
}

// Iff returns x iff y.
// Corresponds to Z3_mk_iff.
func (x *Bool) Iff(y *Bool) *Bool {
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_iff(x.ctx, x.ast, y.ast),
		},
	}
}

// Implies returns x implies y.
// Corresponds to Z3_mk_implies.
func (x *Bool) Implies(y *Bool) *Bool {
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_implies(x.ctx, x.ast, y.ast),
		},
	}
}

// Xor returns x xor y.
// Corresponds to Z3_mk_xor.
func (x *Bool) Xor(y *Bool) *Bool {
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_xor(x.ctx, x.ast, y.ast),
		},
	}
}

// And returns the boolean and of all parameters.
// Corresponds to Z3_mk_and.
func (x *Bool) And(y ...*Bool) *Bool {
	ys := []C.Z3_ast{x.ast}
	for _, a := range y {
		ys = append(ys, a.ast)
	}
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_and(x.ctx, C.unsigned(len(ys)), &ys[0]),
		},
	}
}

// Or returns the boolean or of all parameters.
// Corresponds to Z3_mk_or.
func (x *Bool) Or(y ...*Bool) *Bool {
	ys := []C.Z3_ast{x.ast}
	for _, a := range y {
		ys = append(ys, a.ast)
	}
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_or(x.ctx, C.unsigned(len(ys)), &ys[0]),
		},
	}
}

// Eq returns x == y.
// Corresponds to Z3_mk_eq.
func (x *Bool) Eq(y *Bool) *Bool {
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_eq(x.ctx, x.ast, y.ast),
		},
	}
}

// Distinct returns a predicate representing whether all input parameters are distinct.
// Corresponds to Z3_mk_distinct.
func (x *Bool) Distinct(y ...*Bool) *Bool {
	ys := []C.Z3_ast{x.ast}
	for _, a := range y {
		ys = append(ys, a.ast)
	}
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_distinct(x.ctx, C.unsigned(len(ys)), &ys[0]),
		},
	}
}

// ITE returns x if c else y.
// Corresponds to Z3_mk_ite.
func (x *Bool) ITE(c *Bool, y *Bool) *Bool {
	return &Bool{
		value: value{
			ctx: x.ctx,
			ast: C.Z3_mk_ite(x.ctx, c.ast, x.ast, y.ast),
		},
	}
}

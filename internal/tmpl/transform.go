package tmpl

import (
	"fmt"
	"go/ast"
	"go/token"
	"strconv"
	"strings"

	"golang.org/x/tools/go/ast/astutil"
	"golang.org/x/xerrors"
)

type visitor struct {
	Pre   astutil.ApplyFunc
	Post  astutil.ApplyFunc
	Error func() error
}

func (v visitor) Transform(n ast.Node) (ast.Node, error) {
	node := astutil.Apply(n, v.Pre, v.Post)
	if err := v.Error(); err != nil {
		return nil, err
	}
	return node, nil
}

func SetPackageName(name string) Transform {
	found := false
	return visitor{
		Post: func(c *astutil.Cursor) bool {
			if _, ok := c.Parent().(*ast.File); ok && c.Name() == "Name" {
				c.Replace(&ast.Ident{
					Name: name,
				})
				found = true
			}
			return true
		},
		Error: func() error {
			if !found {
				return xerrors.New("package declaration not found")
			}
			return nil
		},
	}
}

func replace(name string, sub func(*ast.Ident) ast.Node) Transform {
	n := 0
	return visitor{
		Post: func(c *astutil.Cursor) bool {
			if i, ok := c.Node().(*ast.Ident); ok && i.Name == name {
				c.Replace(sub(i))
				n++
			}
			return true
		},
		Error: func() error {
			if n == 0 {
				return xerrors.New("no replacements")
			}
			return nil
		},
	}
}

func Rename(from, to string) Transform {
	return replace(from, func(i *ast.Ident) ast.Node {
		r := &ast.Ident{}
		*r = *i
		r.Name = to
		return r
	})
}

func DefineLiteral(name string, kind token.Token, value string) Transform {
	return replace(name, func(*ast.Ident) ast.Node {
		return &ast.BasicLit{
			Kind:  kind,
			Value: value,
		}
	})
}

func DefineLiteralf(name string, kind token.Token, format string, args ...interface{}) Transform {
	return DefineLiteral(name, kind, fmt.Sprintf(format, args...))
}

func DefineString(name, value string) Transform {
	return DefineLiteralf(name, token.STRING, "%q", value)
}

func DefineIntDecimal(name string, value int) Transform {
	return DefineLiteralf(name, token.INT, "%d", value)
}

func DefineIntHex(name string, value int) Transform {
	return DefineLiteralf(name, token.INT, "%#x", value)
}

func DefineBool(name string, value bool) Transform {
	return Rename(name, strconv.FormatBool(value))
}

func CommentReplace(old, new string) Transform {
	return visitor{
		Post: func(c *astutil.Cursor) bool {
			switch n := c.Node().(type) {
			case *ast.Comment:
				c.Replace(&ast.Comment{
					Slash: n.Slash,
					Text:  strings.ReplaceAll(n.Text, old, new),
				})
			case *ast.File:
				for _, g := range n.Comments {
					for _, comment := range g.List {
						comment.Text = strings.ReplaceAll(comment.Text, old, new)
					}
				}
			}
			return true
		},
		Error: func() error { return nil },
	}
}

// GeneratedBy replaces the string "CodeGenerationWarning" in comments with a
// standard code generation warning. This is a special case of the
// CommentReplace transform.
func GeneratedBy(by string) Transform {
	warning := fmt.Sprintf("Code generated by %s. DO NOT EDIT.", by)
	return CommentReplace("CodeGenerationWarning", warning)
}

func Preprocessor() Transform {
	return visitor{
		Post: func(c *astutil.Cursor) bool {
			ifstmt, ok := c.Node().(*ast.IfStmt)
			if !ok {
				return true
			}

			value, ok := evalbool(ifstmt.Cond)
			if !ok {
				return true
			}

			if value {
				for _, stmt := range ifstmt.Body.List {
					c.InsertBefore(stmt)
				}
			}

			c.Delete()

			return true
		},
		Error: func() error { return nil },
	}
}

func evalbool(expr ast.Expr) (value, ok bool) {
	ident, ok := expr.(*ast.Ident)
	if !ok {
		return false, false
	}

	value, err := strconv.ParseBool(ident.Name)
	if err != nil {
		return false, false
	}

	return value, true
}

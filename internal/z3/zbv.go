// Code generated by wrap.go. DO NOT EDIT.

package z3

/*
#cgo LDFLAGS: -lz3
#include <z3.h>
*/
import "C"

// Not returns bitwise negation of the vector.
// Corresponds to Z3_mk_bvnot.
func (x *BV) Not() *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvnot(x.ctx, x.ast),
	}
}

// ReduceAnd returns the conjunction of bits in the vector, as a vector of length 1.
// Corresponds to Z3_mk_bvredand.
func (x *BV) ReduceAnd() *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvredand(x.ctx, x.ast),
	}
}

// ReduceOr returns the disjunction of bits in the vector, as a vector of length 1.
// Corresponds to Z3_mk_bvredor.
func (x *BV) ReduceOr() *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvredor(x.ctx, x.ast),
	}
}

// And returns the bitwise and of the input vectors.
// Corresponds to Z3_mk_bvand.
func (x *BV) And(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvand(x.ctx, x.ast, y.ast),
	}
}

// Or returns the bitwise or of the input vectors.
// Corresponds to Z3_mk_bvor.
func (x *BV) Or(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvor(x.ctx, x.ast, y.ast),
	}
}

// Xor returns the bitwise exclusive-or of the input vectors.
// Corresponds to Z3_mk_bvxor.
func (x *BV) Xor(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvxor(x.ctx, x.ast, y.ast),
	}
}

// Nand returns the bitwise nand of the input vectors.
// Corresponds to Z3_mk_bvnand.
func (x *BV) Nand(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvnand(x.ctx, x.ast, y.ast),
	}
}

// Nor returns the bitwise nor of the input vectors.
// Corresponds to Z3_mk_bvnor.
func (x *BV) Nor(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvnor(x.ctx, x.ast, y.ast),
	}
}

// Xnor returns the bitwise xnor of the input vectors.
// Corresponds to Z3_mk_bvxnor.
func (x *BV) Xnor(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvxnor(x.ctx, x.ast, y.ast),
	}
}

// Neg returns twos complement unary minus.
// Corresponds to Z3_mk_bvneg.
func (x *BV) Neg() *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvneg(x.ctx, x.ast),
	}
}

// Add returns standard twos complement addition.
// Corresponds to Z3_mk_bvadd.
func (x *BV) Add(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvadd(x.ctx, x.ast, y.ast),
	}
}

// Sub returns standard twos complement subtraction.
// Corresponds to Z3_mk_bvsub.
func (x *BV) Sub(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsub(x.ctx, x.ast, y.ast),
	}
}

// Mul returns standard twos complement multiplication.
// Corresponds to Z3_mk_bvmul.
func (x *BV) Mul(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvmul(x.ctx, x.ast, y.ast),
	}
}

// Udiv returns unsigned division.
// Corresponds to Z3_mk_bvudiv.
func (x *BV) Udiv(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvudiv(x.ctx, x.ast, y.ast),
	}
}

// Sdiv returns twos complement signed division.
// Corresponds to Z3_mk_bvsdiv.
func (x *BV) Sdiv(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsdiv(x.ctx, x.ast, y.ast),
	}
}

// Urem returns unsigned remainder.
// Corresponds to Z3_mk_bvurem.
func (x *BV) Urem(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvurem(x.ctx, x.ast, y.ast),
	}
}

// Srem returns twos complement signed remainder.
// Corresponds to Z3_mk_bvsrem.
func (x *BV) Srem(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsrem(x.ctx, x.ast, y.ast),
	}
}

// Smod returns twos complement signed remainder (sign follows divisor).
// Corresponds to Z3_mk_bvsmod.
func (x *BV) Smod(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsmod(x.ctx, x.ast, y.ast),
	}
}

// ULT is unsigned less than.
// Corresponds to Z3_mk_bvult.
func (x *BV) ULT(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvult(x.ctx, x.ast, y.ast),
	}
}

// SLT is twos complement signed less than.
// Corresponds to Z3_mk_bvslt.
func (x *BV) SLT(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvslt(x.ctx, x.ast, y.ast),
	}
}

// ULE is unsigned less than or equal to.
// Corresponds to Z3_mk_bvule.
func (x *BV) ULE(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvule(x.ctx, x.ast, y.ast),
	}
}

// SLE is twos complement signed less than or equal to.
// Corresponds to Z3_mk_bvsle.
func (x *BV) SLE(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsle(x.ctx, x.ast, y.ast),
	}
}

// UGE is unsigned greater than or equal to.
// Corresponds to Z3_mk_bvuge.
func (x *BV) UGE(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvuge(x.ctx, x.ast, y.ast),
	}
}

// SGE is twos complement signed greater than or equal to.
// Corresponds to Z3_mk_bvsge.
func (x *BV) SGE(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsge(x.ctx, x.ast, y.ast),
	}
}

// UGT is unsigned greater than.
// Corresponds to Z3_mk_bvugt.
func (x *BV) UGT(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvugt(x.ctx, x.ast, y.ast),
	}
}

// SGT is twos complement signed greater than.
// Corresponds to Z3_mk_bvsgt.
func (x *BV) SGT(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsgt(x.ctx, x.ast, y.ast),
	}
}

// Concat concatenates the given bit-vectors.
// Corresponds to Z3_mk_concat.
func (x *BV) Concat(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_concat(x.ctx, x.ast, y.ast),
	}
}

// Extract the bits high down to low from a bit-vector of size m to yield a new bit-vector of size n, where n = high - low + 1.
// Corresponds to Z3_mk_extract.
func (x *BV) Extract(high uint, low uint) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_extract(x.ctx, C.unsigned(high), C.unsigned(low), x.ast),
	}
}

// SignExt the given bit-vector to the (signed) equivalent bit-vector of size m+i, where m is the size of the given bit-vector.
// Corresponds to Z3_mk_sign_ext.
func (x *BV) SignExt(i uint) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_sign_ext(x.ctx, C.unsigned(i), x.ast),
	}
}

// ZeroExt extends the given bit-vector with zeros to the (unsigned) equivalent bit-vector of size m+i, where m is the size of the given bit-vector.
// Corresponds to Z3_mk_zero_ext.
func (x *BV) ZeroExt(i uint) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_zero_ext(x.ctx, C.unsigned(i), x.ast),
	}
}

// Repeat the given bit-vector up length i.
// Corresponds to Z3_mk_repeat.
func (x *BV) Repeat(i uint) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_repeat(x.ctx, C.unsigned(i), x.ast),
	}
}

// Shl returns x << y.
// Corresponds to Z3_mk_bvshl.
func (x *BV) Shl(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvshl(x.ctx, x.ast, y.ast),
	}
}

// LogicShr returns x >> y.
// Corresponds to Z3_mk_bvlshr.
func (x *BV) LogicShr(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvlshr(x.ctx, x.ast, y.ast),
	}
}

// ArithShr returns the arithmetic right shift of x by y.
// Corresponds to Z3_mk_bvashr.
func (x *BV) ArithShr(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvashr(x.ctx, x.ast, y.ast),
	}
}

// RotateLeft rotates the bits of x to the left i times.
// Corresponds to Z3_mk_rotate_left.
func (x *BV) RotateLeft(i uint) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_rotate_left(x.ctx, C.unsigned(i), x.ast),
	}
}

// RotateRight rotates the bits of x to the right i times.
// Corresponds to Z3_mk_rotate_right.
func (x *BV) RotateRight(i uint) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_rotate_right(x.ctx, C.unsigned(i), x.ast),
	}
}

// ExtRotateLeft rotates the bits of x to the left y times.
// Corresponds to Z3_mk_ext_rotate_left.
func (x *BV) ExtRotateLeft(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_ext_rotate_left(x.ctx, x.ast, y.ast),
	}
}

// ExtRotateRight rotates the bits of x to the right y times.
// Corresponds to Z3_mk_ext_rotate_right.
func (x *BV) ExtRotateRight(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_ext_rotate_right(x.ctx, x.ast, y.ast),
	}
}

// AddNoOverflow returns a predicate that checks that the bit-wise addition of x and y does not overflow.
// Corresponds to Z3_mk_bvadd_no_overflow.
func (x *BV) AddNoOverflow(y *BV, signed bool) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvadd_no_overflow(x.ctx, x.ast, y.ast, C.bool(signed)),
	}
}

// AddNoUnderflow returns a predicate that checks that the bit-wise addition of x and y does not overflow.
// Corresponds to Z3_mk_bvadd_no_underflow.
func (x *BV) AddNoUnderflow(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvadd_no_underflow(x.ctx, x.ast, y.ast),
	}
}

// SubNoOverflow creates a predicate that checks that the bit-wise signed subtraction of x and y does not overflow.
// Corresponds to Z3_mk_bvsub_no_overflow.
func (x *BV) SubNoOverflow(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsub_no_overflow(x.ctx, x.ast, y.ast),
	}
}

// SubNoUnderflow creates a predicate that checks that the bit-wise subtraction of x and y does not underflow.
// Corresponds to Z3_mk_bvsub_no_underflow.
func (x *BV) SubNoUnderflow(y *BV, signed bool) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsub_no_underflow(x.ctx, x.ast, y.ast, C.bool(signed)),
	}
}

// SdivNoOverflow creates a predicate that checks that the bit-wise signed division of x and y does not overflow.
// Corresponds to Z3_mk_bvsdiv_no_overflow.
func (x *BV) SdivNoOverflow(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvsdiv_no_overflow(x.ctx, x.ast, y.ast),
	}
}

// NegNoOverflow check that bit-wise negation does not overflow when x is interpreted as a signed bit-vector.
// Corresponds to Z3_mk_bvneg_no_overflow.
func (x *BV) NegNoOverflow() *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvneg_no_overflow(x.ctx, x.ast),
	}
}

// MulNoOverflow creates a predicate that checks that the bit-wise multiplication of x and y does not overflow.
// Corresponds to Z3_mk_bvmul_no_overflow.
func (x *BV) MulNoOverflow(y *BV, signed bool) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvmul_no_overflow(x.ctx, x.ast, y.ast, C.bool(signed)),
	}
}

// MulNoUnderflow creates a predicate that checks that the bit-wise signed multiplication of x and y does not underflow.
// Corresponds to Z3_mk_bvmul_no_underflow.
func (x *BV) MulNoUnderflow(y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_bvmul_no_underflow(x.ctx, x.ast, y.ast),
	}
}

// Eq returns x == y.
// Corresponds to Z3_mk_eq.
func (x *BV) Eq(y *BV) *Bool {
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_eq(x.ctx, x.ast, y.ast),
	}
}

// Distinct returns a predicate representing whether all input parameters are distinct.
// Corresponds to Z3_mk_distinct.
func (x *BV) Distinct(y ...*BV) *Bool {
	ys := []C.Z3_ast{x.ast}
	for _, a := range y {
		ys = append(ys, a.ast)
	}
	return &Bool{
		ctx: x.ctx,
		ast: C.Z3_mk_distinct(x.ctx, C.unsigned(len(ys)), &ys[0]),
	}
}

// ITE returns x if c else y.
// Corresponds to Z3_mk_ite.
func (x *BV) ITE(c Bool, y *BV) *BV {
	return &BV{
		ctx: x.ctx,
		ast: C.Z3_mk_ite(x.ctx, c.ast, x.ast, y.ast),
	}
}

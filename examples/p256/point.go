// Code generated by ec3. DO NOT EDIT.

package p256

import "math/big"

var (
	bi, _ = new(big.Int).SetString("41058363725152142129326129780047268409114441015993725554835256314039467401291", 10)
	b     = new(Elt).SetIntEncode(bi)
)

type Affine struct {
	X Elt
	Y Elt
}

func NewAffine(X, Y *big.Int) *Affine {
	p := new(Affine)
	p.X.SetInt(X)
	p.Y.SetInt(Y)
	Encode(&p.X, &p.X)
	Encode(&p.Y, &p.Y)
	return p
}

func (p *Affine) Set(q *Affine) {
	*p = *q
}

func (p *Affine) Coordinates() (X, Y *big.Int) {
	var dX, dY Elt
	Decode(&dX, &p.X)
	Decode(&dY, &p.Y)
	X = dX.Int()
	Y = dY.Int()
	return
}

func (a *Affine) Jacobian() (p *Jacobian) {
	p = new(Jacobian)
	p.X = a.X
	p.Y = a.Y
	p.Z.SetInt64(1)
	Encode(&p.Z, &p.Z)
	return
}

type Jacobian struct {
	X Elt
	Y Elt
	Z Elt
}

func NewJacobian(X, Y, Z *big.Int) *Jacobian {
	p := new(Jacobian)
	p.X.SetInt(X)
	p.Y.SetInt(Y)
	p.Z.SetInt(Z)
	Encode(&p.X, &p.X)
	Encode(&p.Y, &p.Y)
	Encode(&p.Z, &p.Z)
	return p
}

func (p *Jacobian) Set(q *Jacobian) {
	*p = *q
}

func (p *Jacobian) Coordinates() (X, Y, Z *big.Int) {
	var dX, dY, dZ Elt
	Decode(&dX, &p.X)
	Decode(&dY, &p.Y)
	Decode(&dZ, &p.Z)
	X = dX.Int()
	Y = dY.Int()
	Z = dZ.Int()
	return
}

func (p *Jacobian) Affine() (a *Affine) {
	a = new(Affine)
	var (
		A  Elt
		AA Elt
		t0 Elt
	)

	Inv(&A, &p.Z)
	Sqr(&AA, &A)
	Mul(&a.X, &p.X, &AA)
	Mul(&t0, &AA, &A)
	Mul(&a.Y, &p.Y, &t0)
	return
}

func (p *Jacobian) Projective() (q *Projective) {
	q = new(Projective)
	Mul(&q.X, &p.X, &p.Z)
	q.Y = p.Y
	Sqr(&q.Z, &p.Z)
	Mul(&q.Z, &q.Z, &p.Z)
	return
}

func (p *Jacobian) CMov(q *Jacobian, c uint) {
	CMov(&p.X, &q.X, c)
	CMov(&p.Y, &q.Y, c)
	CMov(&p.Z, &q.Z, c)
}

func (p *Jacobian) CNeg(c uint) {
	var t Elt
	Neg(&t, &p.Y)
	CMov(&p.Y, &t, c)
}

func (p *Jacobian) Add(q *Jacobian, r *Jacobian) {
	var (
		H    Elt
		I    Elt
		J    Elt
		S1   Elt
		S2   Elt
		U1   Elt
		U2   Elt
		V    Elt
		Z1Z1 Elt
		Z2Z2 Elt
		r_   Elt
		t0   Elt
		t1   Elt
		t10  Elt
		t11  Elt
		t12  Elt
		t13  Elt
		t14  Elt
		t2   Elt
		t3   Elt
		t4   Elt
		t5   Elt
		t6   Elt
		t7   Elt
		t8   Elt
		t9   Elt
	)

	Sqr(&Z1Z1, &q.Z)
	Sqr(&Z2Z2, &r.Z)
	Mul(&U1, &q.X, &Z2Z2)
	Mul(&U2, &r.X, &Z1Z1)
	Mul(&t0, &r.Z, &Z2Z2)
	Mul(&S1, &q.Y, &t0)
	Mul(&t1, &q.Z, &Z1Z1)
	Mul(&S2, &r.Y, &t1)
	Sub(&H, &U2, &U1)
	Add(&t2, &H, &H)
	Sqr(&I, &t2)
	Mul(&J, &H, &I)
	Sub(&t3, &S2, &S1)
	Add(&r_, &t3, &t3)
	Mul(&V, &U1, &I)
	Sqr(&t4, &r_)
	Add(&t5, &V, &V)
	Sub(&t6, &t4, &J)
	Sub(&p.X, &t6, &t5)
	Sub(&t7, &V, &p.X)
	Mul(&t8, &S1, &J)
	Add(&t9, &t8, &t8)
	Mul(&t10, &r_, &t7)
	Sub(&p.Y, &t10, &t9)
	Add(&t11, &q.Z, &r.Z)
	Sqr(&t12, &t11)
	Sub(&t13, &t12, &Z1Z1)
	Sub(&t14, &t13, &Z2Z2)
	Mul(&p.Z, &t14, &H)
}

func (p *Jacobian) Double(q *Jacobian) {
	var (
		alpha Elt
		beta  Elt
		delta Elt
		gamma Elt
		t0    Elt
		t1    Elt
		t10   Elt
		t11   Elt
		t12   Elt
		t2    Elt
		t3    Elt
		t4    Elt
		t5    Elt
		t6    Elt
		t7    Elt
		t8    Elt
		t9    Elt
	)

	Sqr(&delta, &q.Z)
	Sqr(&gamma, &q.Y)
	Mul(&beta, &q.X, &gamma)
	Sub(&t0, &q.X, &delta)
	Add(&t1, &q.X, &delta)
	Mul(&t2, &t0, &t1)
	Add(&alpha, &t2, &t2)
	Add(&alpha, &alpha, &t2)
	Sqr(&t3, &alpha)
	Add(&t4, &beta, &beta)
	Add(&t4, &t4, &t4)
	Add(&t4, &t4, &t4)
	Sub(&p.X, &t3, &t4)
	Add(&t5, &q.Y, &q.Z)
	Sqr(&t6, &t5)
	Sub(&t7, &t6, &gamma)
	Sub(&p.Z, &t7, &delta)
	Add(&t8, &beta, &beta)
	Add(&t8, &t8, &t8)
	Sub(&t9, &t8, &p.X)
	Sqr(&t10, &gamma)
	Add(&t11, &t10, &t10)
	Add(&t11, &t11, &t11)
	Add(&t11, &t11, &t11)
	Mul(&t12, &alpha, &t9)
	Sub(&p.Y, &t12, &t11)
}

type Projective struct {
	X Elt
	Y Elt
	Z Elt
}

func NewProjective(X, Y, Z *big.Int) *Projective {
	p := new(Projective)
	p.X.SetInt(X)
	p.Y.SetInt(Y)
	p.Z.SetInt(Z)
	Encode(&p.X, &p.X)
	Encode(&p.Y, &p.Y)
	Encode(&p.Z, &p.Z)
	return p
}

func (p *Projective) Set(q *Projective) {
	*p = *q
}

func (p *Projective) Coordinates() (X, Y, Z *big.Int) {
	var dX, dY, dZ Elt
	Decode(&dX, &p.X)
	Decode(&dY, &p.Y)
	Decode(&dZ, &p.Z)
	X = dX.Int()
	Y = dY.Int()
	Z = dZ.Int()
	return
}

func (p *Projective) Affine() (a *Affine) {
	a = new(Affine)
	var A Elt
	Inv(&A, &p.Z)
	Mul(&a.X, &A, &p.X)
	Mul(&a.Y, &A, &p.Y)
	return
}

func (p *Projective) CNeg(c uint) {
	var t Elt
	Neg(&t, &p.Y)
	CMov(&p.Y, &t, c)
}

func (p *Projective) CompleteAdd(q *Projective, r *Projective) {
	var (
		t0 Elt
		t1 Elt
		t2 Elt
		t3 Elt
		t4 Elt
		t5 Elt
	)

	Mul(&t0, &q.X, &r.X)
	Mul(&t1, &q.Y, &r.Y)
	Mul(&t2, &q.Z, &r.Z)
	Add(&t3, &q.X, &q.Y)
	Add(&t4, &r.X, &r.Y)
	Mul(&t3, &t3, &t4)
	Add(&t4, &t0, &t1)
	Sub(&t3, &t3, &t4)
	Add(&t4, &q.Y, &q.Z)
	Add(&t5, &r.Y, &r.Z)
	Mul(&t4, &t4, &t5)
	Add(&t5, &t1, &t2)
	Sub(&t4, &t4, &t5)
	Add(&t5, &q.X, &q.Z)
	Add(&p.Y, &r.X, &r.Z)
	Mul(&t5, &t5, &p.Y)
	Add(&p.Y, &t0, &t2)
	Sub(&p.Y, &t5, &p.Y)
	Mul(&p.Z, b, &t2)
	Sub(&t5, &p.Y, &p.Z)
	Add(&p.Z, &t5, &t5)
	Add(&t5, &t5, &p.Z)
	Sub(&p.Z, &t1, &t5)
	Add(&t5, &t1, &t5)
	Mul(&p.Y, b, &p.Y)
	Add(&t1, &t2, &t2)
	Add(&t2, &t1, &t2)
	Sub(&p.Y, &p.Y, &t2)
	Sub(&p.Y, &p.Y, &t0)
	Add(&t1, &p.Y, &p.Y)
	Add(&p.Y, &t1, &p.Y)
	Add(&t1, &t0, &t0)
	Add(&t0, &t1, &t0)
	Sub(&t0, &t0, &t2)
	Mul(&t1, &t4, &p.Y)
	Mul(&t2, &t0, &p.Y)
	Mul(&p.Y, &t5, &p.Z)
	Add(&p.Y, &p.Y, &t2)
	Mul(&t5, &t3, &t5)
	Sub(&t5, &t5, &t1)
	Mul(&p.Z, &t4, &p.Z)
	Mul(&t1, &t3, &t0)
	Add(&p.Z, &p.Z, &t1)
	p.X = t5
}

// Code generated by ec3. DO NOT EDIT.

package p256

import "math/big"

// scalarsize is the size of a field element in bytes.
const scalarsize = 32

// scalar is a field element.
type scalar [32]uint8

// scalarp is the field prime modulus as a big integer.
var scalarp, _ = new(big.Int).SetString("115792089210356248762697446949407573529996955224135760342422259061068512044369", 10)

// scalarprime is the prime field modulus as a field element.
var scalarprime = scalar{
	0x51, 0x25, 0x63, 0xfc, 0xc2, 0xca, 0xb9, 0xf3,
	0x84, 0x9e, 0x17, 0xa7, 0xad, 0xfa, 0xe6, 0xbc,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
}

// SetInt64 constructs a field element from an integer.
func (x *scalar) SetInt64(y int64) *scalar {
	x.SetInt(big.NewInt(y))
	return x
}

// SetInt constructs a field element from a big integer.
func (x *scalar) SetInt(y *big.Int) *scalar {
	// Reduce if outside range.
	if y.Sign() < 0 || y.Cmp(scalarp) >= 0 {
		y = new(big.Int).Mod(y, scalarp)
	}
	// Copy bytes into field element.
	b := y.Bytes()
	i := 0
	for ; i < len(b); i++ {
		x[i] = b[len(b)-1-i]
	}
	for ; i < scalarsize; i++ {
		x[i] = 0
	}
	return x
}

// SetBytes constructs a field element from bytes in big-endian order.
func (x *scalar) SetBytes(b []byte) *scalar {
	x.SetInt(new(big.Int).SetBytes(b))
	return x
}

// Int converts to a big integer.
func (x *scalar) Int() *big.Int {
	// Endianness swap.
	var be scalar
	for i := 0; i < scalarsize; i++ {
		be[scalarsize-1-i] = x[i]
	}
	// Build big.Int.
	return new(big.Int).SetBytes(be[:])
}

// scalarone is the field element 1.
var scalarone = new(scalar).SetInt64(1)

// scalardecode decodes from the Montgomery domain.
func scalardecode(z *scalar, x *scalar) {
	scalarmul(z, x, scalarone)
}

// scalarr2 is the multiplier R^2 for encoding into the Montgomery domain.
var scalarr2 = new(scalar).SetInt(new(big.Int).Lsh(big.NewInt(1), 2*256))

// scalarencode encodes into the Montgomery domain.
func scalarencode(z *scalar, x *scalar) {
	scalarmul(z, x, scalarr2)
}

// scalarneg computes z = -x (mod p).
func scalarneg(z *scalar, x *scalar) {
	scalarsub(z, &scalarprime, x)
}

// scalarsqr computes z = x^2 (mod p).
func scalarsqr(z *scalar, x *scalar) {
	scalarmul(z, x, x)
}

// scalarinv computes z = 1/x (mod p).
func scalarinv(z *scalar, x *scalar) {
	// Inversion computation is derived from the addition chain:
	//
	// _10       = 2*1
	// _100      = 2*_10
	// _101      = 1 + _100
	// _110      = 1 + _101
	// _1001     = _100 + _101
	// _1111     = _110 + _1001
	// _10010    = 2*_1001
	// _10101    = _110 + _1111
	// _11000    = _110 + _10010
	// _11010    = _10 + _11000
	// _101111   = _10101 + _11010
	// _111000   = _1001 + _101111
	// _111101   = _101 + _111000
	// _111111   = _10 + _111101
	// _1001111  = _10010 + _111101
	// _1100001  = _10010 + _1001111
	// _1100011  = _10 + _1100001
	// _1110011  = _10010 + _1100001
	// _1110111  = _100 + _1110011
	// _1111101  = _110 + _1110111
	// _10010101 = _11000 + _1111101
	// _10100111 = _10010 + _10010101
	// _10101101 = _110 + _10100111
	// _11100101 = _111000 + _10101101
	// _11111111 = _11010 + _11100101
	// x16       = _11111111 << 8 + _11111111
	// x32       = x16 << 16 + x16
	// i133      = ((x32 << 48 + x16) << 16 + x16) << 16
	// i158      = ((x16 + i133) << 16 + x16) << 6 + _101111
	// i186      = ((i158 << 9 + _1110011) << 8 + _1111101) << 9
	// i206      = ((_10101101 + i186) << 8 + _10100111) << 9 + _101111
	// i236      = ((i206 << 8 + _111101) << 11 + _1001111) << 9
	// i257      = ((_1110111 + i236) << 10 + _11100101) << 8 + _1100001
	// i286      = ((i257 << 7 + _111111) << 10 + _1100011) << 10
	// return      (_10010101 + i286) << 6 + _1111
	//
	// Operations: 251 squares 43 multiplies

	// Allocate 15 temporaries.
	var t [15]scalar

	// Step 1: &t[1] = x^0x2.
	scalarsqr(&t[1], x)

	// Step 2: &t[5] = x^0x4.
	scalarsqr(&t[5], &t[1])

	// Step 3: &t[2] = x^0x5.
	scalarmul(&t[2], x, &t[5])

	// Step 4: &t[10] = x^0x6.
	scalarmul(&t[10], x, &t[2])

	// Step 5: &t[3] = x^0x9.
	scalarmul(&t[3], &t[5], &t[2])

	// Step 6: z = x^0xf.
	scalarmul(z, &t[10], &t[3])

	// Step 7: &t[9] = x^0x12.
	scalarsqr(&t[9], &t[3])

	// Step 8: &t[4] = x^0x15.
	scalarmul(&t[4], &t[10], z)

	// Step 9: &t[0] = x^0x18.
	scalarmul(&t[0], &t[10], &t[9])

	// Step 10: &t[13] = x^0x1a.
	scalarmul(&t[13], &t[1], &t[0])

	// Step 11: &t[8] = x^0x2f.
	scalarmul(&t[8], &t[4], &t[13])

	// Step 12: &t[4] = x^0x38.
	scalarmul(&t[4], &t[3], &t[8])

	// Step 13: &t[7] = x^0x3d.
	scalarmul(&t[7], &t[2], &t[4])

	// Step 14: &t[2] = x^0x3f.
	scalarmul(&t[2], &t[1], &t[7])

	// Step 15: &t[6] = x^0x4f.
	scalarmul(&t[6], &t[9], &t[7])

	// Step 16: &t[3] = x^0x61.
	scalarmul(&t[3], &t[9], &t[6])

	// Step 17: &t[1] = x^0x63.
	scalarmul(&t[1], &t[1], &t[3])

	// Step 18: &t[12] = x^0x73.
	scalarmul(&t[12], &t[9], &t[3])

	// Step 19: &t[5] = x^0x77.
	scalarmul(&t[5], &t[5], &t[12])

	// Step 20: &t[11] = x^0x7d.
	scalarmul(&t[11], &t[10], &t[5])

	// Step 21: &t[0] = x^0x95.
	scalarmul(&t[0], &t[0], &t[11])

	// Step 22: &t[9] = x^0xa7.
	scalarmul(&t[9], &t[9], &t[0])

	// Step 23: &t[10] = x^0xad.
	scalarmul(&t[10], &t[10], &t[9])

	// Step 24: &t[4] = x^0xe5.
	scalarmul(&t[4], &t[4], &t[10])

	// Step 25: &t[13] = x^0xff.
	scalarmul(&t[13], &t[13], &t[4])

	// Step 33: &t[14] = x^0xff00.
	scalarsqr(&t[14], &t[13])
	for s := 1; s < 8; s++ {
		scalarsqr(&t[14], &t[14])
	}

	// Step 34: &t[13] = x^0xffff.
	scalarmul(&t[13], &t[13], &t[14])

	// Step 50: &t[14] = x^0xffff0000.
	scalarsqr(&t[14], &t[13])
	for s := 1; s < 16; s++ {
		scalarsqr(&t[14], &t[14])
	}

	// Step 51: &t[14] = x^0xffffffff.
	scalarmul(&t[14], &t[13], &t[14])

	// Step 99: &t[14] = x^0xffffffff000000000000.
	for s := 0; s < 48; s++ {
		scalarsqr(&t[14], &t[14])
	}

	// Step 100: &t[14] = x^0xffffffff00000000ffff.
	scalarmul(&t[14], &t[13], &t[14])

	// Step 116: &t[14] = x^0xffffffff00000000ffff0000.
	for s := 0; s < 16; s++ {
		scalarsqr(&t[14], &t[14])
	}

	// Step 117: &t[14] = x^0xffffffff00000000ffffffff.
	scalarmul(&t[14], &t[13], &t[14])

	// Step 133: &t[14] = x^0xffffffff00000000ffffffff0000.
	for s := 0; s < 16; s++ {
		scalarsqr(&t[14], &t[14])
	}

	// Step 134: &t[14] = x^0xffffffff00000000ffffffffffff.
	scalarmul(&t[14], &t[13], &t[14])

	// Step 150: &t[14] = x^0xffffffff00000000ffffffffffff0000.
	for s := 0; s < 16; s++ {
		scalarsqr(&t[14], &t[14])
	}

	// Step 151: &t[13] = x^0xffffffff00000000ffffffffffffffff.
	scalarmul(&t[13], &t[13], &t[14])

	// Step 157: &t[13] = x^0x3fffffffc00000003fffffffffffffffc0.
	for s := 0; s < 6; s++ {
		scalarsqr(&t[13], &t[13])
	}

	// Step 158: &t[13] = x^0x3fffffffc00000003fffffffffffffffef.
	scalarmul(&t[13], &t[8], &t[13])

	// Step 167: &t[13] = x^0x7fffffff800000007fffffffffffffffde00.
	for s := 0; s < 9; s++ {
		scalarsqr(&t[13], &t[13])
	}

	// Step 168: &t[12] = x^0x7fffffff800000007fffffffffffffffde73.
	scalarmul(&t[12], &t[12], &t[13])

	// Step 176: &t[12] = x^0x7fffffff800000007fffffffffffffffde7300.
	for s := 0; s < 8; s++ {
		scalarsqr(&t[12], &t[12])
	}

	// Step 177: &t[11] = x^0x7fffffff800000007fffffffffffffffde737d.
	scalarmul(&t[11], &t[11], &t[12])

	// Step 186: &t[11] = x^0xffffffff00000000ffffffffffffffffbce6fa00.
	for s := 0; s < 9; s++ {
		scalarsqr(&t[11], &t[11])
	}

	// Step 187: &t[10] = x^0xffffffff00000000ffffffffffffffffbce6faad.
	scalarmul(&t[10], &t[10], &t[11])

	// Step 195: &t[10] = x^0xffffffff00000000ffffffffffffffffbce6faad00.
	for s := 0; s < 8; s++ {
		scalarsqr(&t[10], &t[10])
	}

	// Step 196: &t[9] = x^0xffffffff00000000ffffffffffffffffbce6faada7.
	scalarmul(&t[9], &t[9], &t[10])

	// Step 205: &t[9] = x^0x1fffffffe00000001ffffffffffffffff79cdf55b4e00.
	for s := 0; s < 9; s++ {
		scalarsqr(&t[9], &t[9])
	}

	// Step 206: &t[8] = x^0x1fffffffe00000001ffffffffffffffff79cdf55b4e2f.
	scalarmul(&t[8], &t[8], &t[9])

	// Step 214: &t[8] = x^0x1fffffffe00000001ffffffffffffffff79cdf55b4e2f00.
	for s := 0; s < 8; s++ {
		scalarsqr(&t[8], &t[8])
	}

	// Step 215: &t[7] = x^0x1fffffffe00000001ffffffffffffffff79cdf55b4e2f3d.
	scalarmul(&t[7], &t[7], &t[8])

	// Step 226: &t[7] = x^0xffffffff00000000ffffffffffffffffbce6faada7179e800.
	for s := 0; s < 11; s++ {
		scalarsqr(&t[7], &t[7])
	}

	// Step 227: &t[6] = x^0xffffffff00000000ffffffffffffffffbce6faada7179e84f.
	scalarmul(&t[6], &t[6], &t[7])

	// Step 236: &t[6] = x^0x1fffffffe00000001ffffffffffffffff79cdf55b4e2f3d09e00.
	for s := 0; s < 9; s++ {
		scalarsqr(&t[6], &t[6])
	}

	// Step 237: &t[5] = x^0x1fffffffe00000001ffffffffffffffff79cdf55b4e2f3d09e77.
	scalarmul(&t[5], &t[5], &t[6])

	// Step 247: &t[5] = x^0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dc00.
	for s := 0; s < 10; s++ {
		scalarsqr(&t[5], &t[5])
	}

	// Step 248: &t[4] = x^0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5.
	scalarmul(&t[4], &t[4], &t[5])

	// Step 256: &t[4] = x^0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce500.
	for s := 0; s < 8; s++ {
		scalarsqr(&t[4], &t[4])
	}

	// Step 257: &t[3] = x^0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce561.
	scalarmul(&t[3], &t[3], &t[4])

	// Step 264: &t[3] = x^0x3fffffffc00000003fffffffffffffffef39beab69c5e7a13cee72b080.
	for s := 0; s < 7; s++ {
		scalarsqr(&t[3], &t[3])
	}

	// Step 265: &t[2] = x^0x3fffffffc00000003fffffffffffffffef39beab69c5e7a13cee72b0bf.
	scalarmul(&t[2], &t[2], &t[3])

	// Step 275: &t[2] = x^0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc00.
	for s := 0; s < 10; s++ {
		scalarsqr(&t[2], &t[2])
	}

	// Step 276: &t[1] = x^0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63.
	scalarmul(&t[1], &t[1], &t[2])

	// Step 286: &t[1] = x^0x3fffffffc00000003fffffffffffffffef39beab69c5e7a13cee72b0bf18c00.
	for s := 0; s < 10; s++ {
		scalarsqr(&t[1], &t[1])
	}

	// Step 287: &t[0] = x^0x3fffffffc00000003fffffffffffffffef39beab69c5e7a13cee72b0bf18c95.
	scalarmul(&t[0], &t[0], &t[1])

	// Step 293: &t[0] = x^0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632540.
	for s := 0; s < 6; s++ {
		scalarsqr(&t[0], &t[0])
	}

	// Step 294: z = x^0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc63254f.
	scalarmul(z, z, &t[0])
}
